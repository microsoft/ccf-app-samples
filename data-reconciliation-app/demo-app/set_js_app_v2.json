{"actions":[{"name":"set_js_app","args":{"bundle":{"metadata":{"endpoints":{"/ingest":{"post":{"js_module":"endpoints/ingest.js","js_function":"postHandler","forwarding_required":"always","authn_policies":["member_cert","user_cert"],"mode":"readwrite","openapi":{"responses":{"200":{"description":"Ok","content":{"application/json":{"schema":{"type":"object"}}}}},"requestBody":{"required":true,"content":{"application/json":{"schema":{"type":"array"}}}}}}},"/report":{"get":{"js_module":"endpoints/reporting.js","js_function":"getAllHandler","forwarding_required":"always","authn_policies":["member_cert","user_cert"],"mode":"readonly","openapi":{"responses":{"200":{"description":"Ok","content":{"application/json":{"schema":{"type":"object"}}}}}}}},"/report/{id}":{"get":{"js_module":"endpoints/reporting.js","js_function":"getByIdHandler","forwarding_required":"always","authn_policies":["member_cert","user_cert"],"mode":"readonly","openapi":{"responses":{"200":{"description":"Ok","content":{"application/json":{"schema":{"type":"object"}}}}}}}}}},"modules":[{"name":"endpoints/all.js","module":"export { postHandler } from './ingest.js';\nexport { getAllHandler, getByIdHandler } from './reporting.js';\n"},{"name":"endpoints/ingest.js","module":"import { ServiceResult } from '../utils/service-result.js';\nimport { ApiResult } from '../utils/api-result.js';\nimport { DataSchema } from '../models/data-schema.js';\nimport authenticationService from '../services/authentication-service.js';\nimport ingestService from '../services/ingest-service.js';\n\nfunction postHandler(request) {\n    const getCallerId = authenticationService.getCallerId(request);\n    if (getCallerId.failure)\n        return ApiResult.Failed(getCallerId);\n    const callerId = getCallerId.content;\n    const isValidIdentity = authenticationService.isValidIdentity(callerId);\n    if (isValidIdentity.failure || !isValidIdentity.content)\n        return ApiResult.AuthFailure();\n    let getJsonData = getBodyAsJson(request);\n    if (getJsonData.failure)\n        return ApiResult.Failed(getJsonData);\n    const data = getJsonData.content;\n    const mapDataRecords = DataSchema.mapDataRecords(data);\n    if (mapDataRecords.failure)\n        return ApiResult.Failed(mapDataRecords);\n    const response = ingestService.submitData(callerId, mapDataRecords.content);\n    return ApiResult.Succeeded(response);\n}\nfunction getBodyAsJson(request) {\n    try {\n        return ServiceResult.Succeeded(request.body.json());\n    }\n    catch (ex) {\n        return ServiceResult.Failed({\n            errorMessage: ex.message,\n            errorType: \"InvalidJSON\",\n            details: ex,\n        });\n    }\n}\n\nexport { postHandler };\n"},{"name":"endpoints/reporting.js","module":"import { ApiResult } from '../utils/api-result.js';\nimport authenticationService from '../services/authentication-service.js';\nimport reportingService from '../services/reporting-service.js';\nimport { DataSchema } from '../models/data-schema.js';\n\nfunction getAllHandler(request) {\n    const getCallerId = authenticationService.getCallerId(request);\n    if (getCallerId.failure)\n        return ApiResult.Failed(getCallerId);\n    const callerId = getCallerId.content;\n    const isValidIdentity = authenticationService.isValidIdentity(callerId);\n    if (isValidIdentity.failure || !isValidIdentity.content)\n        return ApiResult.AuthFailure();\n    const response = reportingService.getData(callerId);\n    if (response.failure)\n        return ApiResult.Failed(response);\n    const mappedRecords = DataSchema.mapSummaryRecords(response.content);\n    return ApiResult.Succeeded(mappedRecords);\n}\nfunction getByIdHandler(request) {\n    const getCallerId = authenticationService.getCallerId(request);\n    if (getCallerId.failure)\n        return ApiResult.Failed(getCallerId);\n    const callerId = getCallerId.content;\n    const isValidIdentity = authenticationService.isValidIdentity(callerId);\n    if (isValidIdentity.failure || !isValidIdentity.content)\n        return ApiResult.AuthFailure();\n    const key = request.params[\"id\"];\n    const response = reportingService.getDataById(callerId, key);\n    if (response.failure)\n        return ApiResult.Failed(response);\n    const mappedRecords = DataSchema.mapSummaryRecord(response.content);\n    return ApiResult.Succeeded(mappedRecords);\n}\n\nexport { getAllHandler, getByIdHandler };\n"},{"name":"models/data-record.js","module":"import { ServiceResult } from '../utils/service-result.js';\n\nclass DataRecord {\n    constructor(props) {\n        this.key = props.key;\n        this.value = props.value;\n        this.type = typeof this.value;\n    }\n    static create(props) {\n        if (!props.key)\n            return ServiceResult.Failed({\n                errorMessage: \"Error: key cannot be null or empty\",\n                errorType: \"InvalidRecordKey\",\n            });\n        if (!props.value)\n            return ServiceResult.Failed({\n                errorMessage: \"Error: value cannot be null or empty\",\n                errorType: \"InvalidRecordValue\",\n            });\n        const dataRecord = new DataRecord(props);\n        return ServiceResult.Succeeded(dataRecord);\n    }\n}\n\nexport { DataRecord };\n"},{"name":"models/data-schema.js","module":"import { ServiceResult } from '../utils/service-result.js';\nimport { DataRecord } from './data-record.js';\n\nclass DataSchema {\n    static mapDataRecord(dataRecord, schema) {\n        if (!dataRecord || !schema) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: data record is null or empty\",\n                errorType: \"InvalidInputFormat\",\n            });\n        }\n        if (!this.hasValidSchema(dataRecord, schema)) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: invalid input schema\",\n                errorType: \"InvalidInputFormat\",\n            });\n        }\n        const key = dataRecord[schema.key.name];\n        const value = dataRecord[schema.value.name];\n        return DataRecord.create({ key: key, value: value });\n    }\n    static mapDataRecords(dataRecords) {\n        if (!dataRecords || dataRecords.length == 0) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: data records is null or empty\",\n                errorType: \"InvalidInputFormat\",\n            });\n        }\n        const schema = DataSchema.getDefaultDataSchema();\n        const mappedRecords = [];\n        dataRecords.forEach((record) => {\n            const mappedRecord = DataSchema.mapDataRecord(record, schema);\n            if (mappedRecord.success) {\n                mappedRecords.push(mappedRecord.content);\n            }\n        });\n        return ServiceResult.Succeeded(mappedRecords);\n    }\n    static mapSummaryRecord(summaryRecord, schema) {\n        if (!schema) {\n            schema = DataSchema.getDefaultDataSchema();\n        }\n        const result = {\n            group_status: summaryRecord.groupStatus,\n            majority_minority: summaryRecord.minorityMajorityStatus,\n            count_of_unique_values: summaryRecord.uniqueValuesCount,\n            members_in_agreement: summaryRecord.membersInAgreementCount,\n            total_votes_count: summaryRecord.votesCount\n        };\n        result[schema.key.name] = summaryRecord.key;\n        result[schema.value.name] = summaryRecord.value;\n        return ServiceResult.Succeeded(result);\n    }\n    static mapSummaryRecords(summaryRecords) {\n        const schema = DataSchema.getDefaultDataSchema();\n        const results = [];\n        if (summaryRecords && summaryRecords.length > 0) {\n            summaryRecords.forEach((record) => {\n                const mappedRecord = DataSchema.mapSummaryRecord(record, schema);\n                if (mappedRecord.success) {\n                    results.push(mappedRecord.content);\n                }\n            });\n        }\n        return ServiceResult.Succeeded(results);\n    }\n    static hasValidSchema(dataRecord, schema) {\n        return (dataRecord.hasOwnProperty(schema.key.name) &&\n            dataRecord.hasOwnProperty(schema.value.name));\n    }\n    static getDefaultDataSchema() {\n        const schema = {\n            key: { name: \"lei\", type: \"string\" },\n            value: { name: \"nace\", type: \"string\" },\n        };\n        return schema;\n    }\n}\n\nexport { DataSchema };\n"},{"name":"models/reconciled-record.js","module":"import { ServiceResult } from '../utils/service-result.js';\n\nclass ReconciledRecord {\n    constructor() {\n        this.values = {};\n    }\n    static create(record, userId) {\n        const newRecord = new ReconciledRecord();\n        newRecord.key = record.key;\n        newRecord.type = record.type;\n        newRecord.values = {};\n        newRecord.values[userId] = record.value;\n        return ServiceResult.Succeeded(newRecord);\n    }\n    static update(record, newRecordValue, userId) {\n        record.key = newRecordValue.key;\n        record.values[userId] = newRecordValue.value;\n        return ServiceResult.Succeeded(record);\n    }\n}\n\nexport { ReconciledRecord };\n"},{"name":"models/summary-record.js","module":"import { MINIMUM_VOTES_THRESHOLD } from '../utils/constants.js';\nimport { ServiceResult } from '../utils/service-result.js';\n\nvar SummaryGroupStatus;\n(function (SummaryGroupStatus) {\n    SummaryGroupStatus[\"NotEnoughData\"] = \"NOT_ENOUGH_DATA\";\n    SummaryGroupStatus[\"LackOfConsensus\"] = \"LACK_OF_CONSENSUS\";\n    SummaryGroupStatus[\"InConsensus\"] = \"IN_CONSENSUS\";\n})(SummaryGroupStatus || (SummaryGroupStatus = {}));\nvar SummaryStatus;\n(function (SummaryStatus) {\n    SummaryStatus[\"Majority\"] = \"Majority\";\n    SummaryStatus[\"Minority\"] = \"Minority\";\n})(SummaryStatus || (SummaryStatus = {}));\nclass SummaryRecord {\n    constructor(summaryRecord) {\n        this.key = summaryRecord.key;\n        this.value = summaryRecord.value;\n        this.type = summaryRecord.type;\n        this.minorityMajorityStatus = summaryRecord.minorityMajorityStatus;\n        this.groupStatus = summaryRecord.groupStatus;\n        this.membersInAgreementCount = summaryRecord.membersInAgreementCount;\n        this.membersInDisagreementCount = summaryRecord.membersInDisagreementCount;\n        this.votesCount = summaryRecord.votesCount;\n        this.uniqueValuesCount = summaryRecord.uniqueValuesCount;\n    }\n    static create(memberId, record) {\n        if (!record.key) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: key cannot be null or empty\",\n                errorType: \"InvalidRecordKey\",\n            });\n        }\n        if (!record.values) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: values can not be null or empty\",\n                errorType: \"InvalidRecordValue\",\n            });\n        }\n        if (!record.values.hasOwnProperty(memberId)) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: The key does not exist\",\n                errorType: \"InvalidRecordKey\",\n            });\n        }\n        const memberIds = Object.keys(record.values);\n        const values = Object.values(record.values);\n        const uniqueValues = new Set(values);\n        const memberValue = record.values[memberId];\n        const votesCount = memberIds.length;\n        const membersInAgreementCount = memberIds.filter((key) => record.values[key] == memberValue).length;\n        const membersInDisagreementCount = memberIds.filter((key) => record.values[key] != memberValue).length;\n        const summary = {\n            key: record.key,\n            value: memberValue,\n            type: record.type,\n            minorityMajorityStatus: this.getSubDivisionStatus(membersInAgreementCount, membersInDisagreementCount),\n            groupStatus: this.getGroupStatus(votesCount, uniqueValues.size),\n            membersInAgreementCount: membersInAgreementCount,\n            membersInDisagreementCount: membersInDisagreementCount,\n            votesCount: votesCount,\n            uniqueValuesCount: uniqueValues.size,\n        };\n        const dataRecord = new SummaryRecord(summary);\n        return ServiceResult.Succeeded(dataRecord);\n    }\n    static getSubDivisionStatus(membersInAgreementCount, membersInDisagreementCount) {\n        if (membersInAgreementCount > membersInDisagreementCount) {\n            return SummaryStatus.Majority;\n        }\n        return SummaryStatus.Minority;\n    }\n    static getGroupStatus(votesCount, uniqueValuesCount) {\n        if (votesCount < MINIMUM_VOTES_THRESHOLD) {\n            return SummaryGroupStatus.NotEnoughData;\n        }\n        else if (uniqueValuesCount != 1) {\n            return SummaryGroupStatus.LackOfConsensus;\n        }\n        return SummaryGroupStatus.InConsensus;\n    }\n}\n\nexport { SummaryGroupStatus, SummaryRecord, SummaryStatus };\n"},{"name":"node_modules/@microsoft/ccf-app/consensus.js","module":"import { ccf } from './global.js';\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n/**\n * @inheritDoc global!CCFConsensus.getLastCommittedTxId\n */\nccf.consensus.getLastCommittedTxId.bind(ccf.consensus);\n/**\n * @inheritDoc global!CCFConsensus.getStatusForTxId\n */\nccf.consensus.getStatusForTxId.bind(ccf.consensus);\n/**\n * @inheritDoc global!CCFConsensus.getViewForSeqno\n */\nccf.consensus.getViewForSeqno.bind(ccf.consensus);\n"},{"name":"node_modules/@microsoft/ccf-app/converters.js","module":"import { ccf } from './global.js';\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\nfunction checkString(val) {\n    if (typeof val !== \"string\") {\n        throw new TypeError(`Value ${val} is not a string`);\n    }\n}\nclass StringConverter {\n    encode(val) {\n        checkString(val);\n        return ccf.strToBuf(val);\n    }\n    decode(buf) {\n        return ccf.bufToStr(buf);\n    }\n}\nclass JSONConverter {\n    encode(val) {\n        return ccf.jsonCompatibleToBuf(val);\n    }\n    decode(buf) {\n        return ccf.bufToJsonCompatible(buf);\n    }\n}\nclass IdentityConverter {\n    encode(val) {\n        return val;\n    }\n    decode(buf) {\n        return buf;\n    }\n}\n/**\n * Converter for `string` values, encoded as UTF-8.\n *\n * Example:\n * ```\n * const buf = ccfapp.string.encode('my-string'); // ArrayBuffer\n * const val = ccfapp.string.decode(buf);         // string\n * ```\n */\nconst string = new StringConverter();\n/**\n * Returns a converter for JSON-compatible objects or values.\n *\n * {@linkcode DataConverter.encode | encode} first serializes the object\n * or value to JSON and then converts the resulting string to an `ArrayBuffer`.\n * JSON serialization uses `JSON.stringify()` without `replacer` or\n * `space` parameters.\n *\n * {@linkcode DataConverter.decode | decode} converts the `ArrayBuffer`\n * to a string and parses it using `JSON.parse()` without `reviver`\n * parameter.\n *\n * Example:\n * ```\n * interface Person {\n *   name: string\n *   age: number\n * }\n * const person: Person = { name: \"John\", age: 42 };\n * const conv = ccfapp.json<Person>();\n * const buffer = conv.encode(person); // ArrayBuffer\n * const person2 = conv.decode(buffer); // Person\n * ```\n */\nconst json = () => new JSONConverter();\n/**\n * Identity converter.\n * {@linkcode DataConverter.encode | encode} / {@linkcode DataConverter.decode | decode}\n * return the input `ArrayBuffer` unchanged. No copy is made.\n *\n * This converter can be used with {@linkcode kv.typedKv} when the key or value\n * type is `ArrayBuffer`, in which case no conversion is applied.\n */\nconst arrayBuffer = new IdentityConverter();\n\nexport { arrayBuffer, json, string };\n"},{"name":"node_modules/@microsoft/ccf-app/endpoints.js","module":"import { ccf } from './global.js';\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n/**\n * @inheritDoc global!CCFRpc.setApplyWrites\n */\nccf.rpc.setApplyWrites.bind(ccf.rpc);\n/**\n * @inheritDoc global!CCFRpc.setClaimsDigest\n */\nccf.rpc.setClaimsDigest.bind(ccf.rpc);\n"},{"name":"node_modules/@microsoft/ccf-app/global.js","module":"// Copyright (c) Microsoft Corporation. All rights reserved.\n// Licensed under the Apache 2.0 License.\n/**\n * This module describes the global {@linkcode ccf} variable.\n * Direct access of this module or the {@linkcode ccf} variable is\n * typically not needed as all of its functionality is exposed\n * via other, often more high-level, modules.\n *\n * Accessing the {@linkcode ccf} global in a type-safe way is done\n * as follows:\n *\n * ```\n * import { ccf } from '@microsoft/ccf-app/global.js';\n * ```\n *\n * @module\n */\n// The global ccf variable and associated types are exported\n// as a regular module instead of using an ambient namespace\n// in a .d.ts definition file.\n// This avoids polluting the global namespace.\nconst ccf = globalThis.ccf;\n\nexport { ccf };\n"},{"name":"node_modules/@microsoft/ccf-app/historical.js","module":"import { ccf } from './global.js';\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\n/**\n * @inheritDoc global!CCF.historicalState\n */\nccf.historicalState;\n/**\n * @inheritDoc global!CCFHistorical.getStateRange\n */\nccf.historical.getStateRange.bind(ccf.historical);\n/**\n * @inheritDoc global!CCFHistorical.dropCachedStates\n */\nccf.historical.dropCachedStates.bind(ccf.historical);\n"},{"name":"node_modules/@microsoft/ccf-app/kv.js","module":"import { ccf } from './global.js';\n\n// Copyright (c) Microsoft Corporation. All rights reserved.\nclass TypedKvMap {\n    constructor(kv, kt, vt) {\n        this.kv = kv;\n        this.kt = kt;\n        this.vt = vt;\n    }\n    has(key) {\n        return this.kv.has(this.kt.encode(key));\n    }\n    get(key) {\n        const v = this.kv.get(this.kt.encode(key));\n        return v === undefined ? undefined : this.vt.decode(v);\n    }\n    set(key, value) {\n        this.kv.set(this.kt.encode(key), this.vt.encode(value));\n        return this;\n    }\n    delete(key) {\n        this.kv.delete(this.kt.encode(key));\n    }\n    clear() {\n        this.kv.clear();\n    }\n    forEach(callback) {\n        let kt = this.kt;\n        let vt = this.vt;\n        let typedMap = this;\n        this.kv.forEach(function (raw_v, raw_k, table) {\n            callback(vt.decode(raw_v), kt.decode(raw_k), typedMap);\n        });\n    }\n    get size() {\n        return this.kv.size;\n    }\n}\n/**\n * Returns a typed view of a map in the Key-Value Store,\n * where keys and values are automatically converted\n * to and from ``ArrayBuffer`` based on the given key\n * and value converters.\n *\n * See the {@linkcode converters} module for available converters.\n *\n * @param nameOrMap Either the map name in the Key-Value Store,\n *    or a ``KvMap`` object.\n * @param kt The converter to use for map keys.\n * @param vt The converter to use for map values.\n */\nfunction typedKv(nameOrMap, kt, vt) {\n    const kvMap = typeof nameOrMap === \"string\" ? ccf.kv[nameOrMap] : nameOrMap;\n    return new TypedKvMap(kvMap, kt, vt);\n}\n/**\n * @inheritDoc global!CCF.kv\n */\nccf.kv;\n\nexport { TypedKvMap, typedKv };\n"},{"name":"repositories/kv-repository.js","module":"import { typedKv } from '../node_modules/@microsoft/ccf-app/kv.js';\nimport { json, string } from '../node_modules/@microsoft/ccf-app/converters.js';\nimport '../node_modules/@microsoft/ccf-app/consensus.js';\nimport '../node_modules/@microsoft/ccf-app/historical.js';\nimport '../node_modules/@microsoft/ccf-app/endpoints.js';\nimport { ServiceResult } from '../utils/service-result.js';\n\nclass KeyValueRepository {\n    constructor(kvStore) {\n        this.kvStore = kvStore;\n    }\n    set(key, value) {\n        try {\n            this.kvStore.set(key, value);\n            return ServiceResult.Succeeded(value);\n        }\n        catch (ex) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: unable to set value to the kvstore\",\n                errorType: \"KeyValueStoreError\",\n                details: ex,\n            });\n        }\n    }\n    get(key) {\n        try {\n            const value = this.kvStore.get(key);\n            if (value === undefined) {\n                return ServiceResult.Failed({\n                    errorMessage: \"Error: key does not exist\",\n                    errorType: \"KeyValueStoreError\",\n                });\n            }\n            return ServiceResult.Succeeded(value);\n        }\n        catch (ex) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: unable to read value from the kvstore\",\n                errorType: \"KeyValueStoreError\",\n                details: ex,\n            });\n        }\n    }\n    has(key) {\n        try {\n            return ServiceResult.Succeeded(this.kvStore.has(key));\n        }\n        catch (ex) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: unable to check if key exists  in the kvstore\",\n                errorType: \"KeyValueStoreError\",\n                details: ex,\n            });\n        }\n    }\n    keys() {\n        try {\n            const keys = [];\n            this.kvStore.forEach((val, key) => {\n                keys.push(key);\n            });\n            return ServiceResult.Succeeded(keys);\n        }\n        catch (ex) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: unable to get kvstore all keys\",\n                errorType: \"KeyValueStoreError\",\n                details: ex,\n            });\n        }\n    }\n    values() {\n        try {\n            const values = [];\n            this.kvStore.forEach((val, key) => {\n                values.push(val);\n            });\n            return ServiceResult.Succeeded(values);\n        }\n        catch (ex) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: unable to get kvstore all values\",\n                errorType: \"KeyValueStoreError\",\n                details: ex,\n            });\n        }\n    }\n    clear() {\n        try {\n            return ServiceResult.Succeeded(this.kvStore.clear());\n        }\n        catch (ex) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: unable to clear kvstore values\",\n                errorType: \"KeyValueStoreError\",\n                details: ex,\n            });\n        }\n    }\n    forEach(callback) {\n        try {\n            this.kvStore.forEach((val, key) => {\n                callback(key, val);\n            });\n            return ServiceResult.Succeeded(\"\");\n        }\n        catch (ex) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: unable to iterate the kvstore pairs\",\n                errorType: \"KeyValueStoreError\",\n                details: ex,\n            });\n        }\n    }\n    get size() {\n        try {\n            return ServiceResult.Succeeded(this.kvStore.size);\n        }\n        catch (ex) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: unable to get the kvstore size\",\n                errorType: \"KeyValueStoreError\",\n                details: ex,\n            });\n        }\n    }\n}\nconst kvStore = typedKv(\"data\", string, json());\nconst keyValueRepository = new KeyValueRepository(kvStore);\n\nexport { KeyValueRepository, keyValueRepository as default };\n"},{"name":"services/authentication-service.js","module":"import { typedKv } from '../node_modules/@microsoft/ccf-app/kv.js';\nimport { arrayBuffer } from '../node_modules/@microsoft/ccf-app/converters.js';\nimport '../node_modules/@microsoft/ccf-app/consensus.js';\nimport '../node_modules/@microsoft/ccf-app/historical.js';\nimport '../node_modules/@microsoft/ccf-app/endpoints.js';\nimport { ccf } from '../node_modules/@microsoft/ccf-app/global.js';\nimport { ServiceResult } from '../utils/service-result.js';\n\nclass CertBasedAuthenticationService {\n    getCallerId(request) {\n        try {\n            const caller = request.caller;\n            if (!caller.id) {\n                return ServiceResult.Failed({\n                    errorMessage: \"Error: invalid caller identity\",\n                    errorType: \"AuthenticationError\",\n                });\n            }\n            return ServiceResult.Succeeded(caller.id);\n        }\n        catch (ex) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error getting caller identity\",\n                errorType: \"AuthenticationError\",\n                details: ex,\n            });\n        }\n    }\n    isUser(userId) {\n        try {\n            if (!userId) {\n                return ServiceResult.Failed({\n                    errorMessage: \"Error: invalid user id\",\n                    errorType: \"AuthenticationError\",\n                });\n            }\n            const usersCerts = typedKv(\"public:ccf.gov.users.certs\", arrayBuffer, arrayBuffer);\n            const result = usersCerts.has(ccf.strToBuf(userId));\n            return ServiceResult.Succeeded(result);\n        }\n        catch (ex) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error getting caller identity\",\n                errorType: \"AuthenticationError\",\n                details: ex,\n            });\n        }\n    }\n    isActiveMember(memberId) {\n        try {\n            if (!memberId) {\n                return ServiceResult.Failed({\n                    errorMessage: \"Error: invalid member id\",\n                    errorType: \"AuthenticationError\",\n                });\n            }\n            const membersCerts = typedKv(\"public:ccf.gov.members.certs\", arrayBuffer, arrayBuffer);\n            const isMember = membersCerts.has(ccf.strToBuf(memberId));\n            const membersInfo = typedKv(\"public:ccf.gov.members.info\", arrayBuffer, arrayBuffer);\n            const memberInfoBuf = membersInfo.get(ccf.strToBuf(memberId));\n            const memberInfo = ccf.bufToJsonCompatible(memberInfoBuf);\n            const isActiveMember = memberInfo && memberInfo.status === \"Active\";\n            return ServiceResult.Succeeded(isActiveMember && isMember);\n        }\n        catch (ex) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: getting caller identity\",\n                errorType: \"AuthenticationError\",\n                details: ex,\n            });\n        }\n    }\n    isValidIdentity(identityId) {\n        if (!identityId) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: invalid caller identity\",\n                errorType: \"AuthenticationError\",\n            });\n        }\n        const isMember = this.isActiveMember(identityId);\n        if (isMember.success && isMember.content) {\n            return ServiceResult.Succeeded(true);\n        }\n        return ServiceResult.Failed({\n            errorMessage: \"Error: invalid caller identity\",\n            errorType: \"AuthenticationError\",\n        });\n    }\n}\nconst authenticationService = new CertBasedAuthenticationService();\n\nexport { CertBasedAuthenticationService, authenticationService as default };\n"},{"name":"services/ingest-service.js","module":"import { ReconciledRecord } from '../models/reconciled-record.js';\nimport { ServiceResult } from '../utils/service-result.js';\nimport keyValueRepository from '../repositories/kv-repository.js';\n\nclass IngestService {\n    constructor(keyValueRepo) {\n        this.keyValueRepo = keyValueRepo;\n    }\n    submitData(userId, dataRecords) {\n        if (!dataRecords || dataRecords.length == 0) {\n            return ServiceResult.Failed({\n                errorMessage: \"Error: ingestion data cannot be null\",\n                errorType: \"InvalidIngestionData\",\n            });\n        }\n        for (const record of dataRecords) {\n            const hasRecord = this.keyValueRepo.has(record.key);\n            if (hasRecord.failure)\n                return ServiceResult.Failed(hasRecord.error);\n            if (hasRecord.content) {\n                const getRecord = this.keyValueRepo.get(record.key);\n                if (getRecord.failure)\n                    return ServiceResult.Failed(getRecord.error);\n                const updateRecord = ReconciledRecord.update(getRecord.content, record, userId);\n                if (updateRecord.failure)\n                    return ServiceResult.Failed(updateRecord.error);\n                const saveRecord = this.keyValueRepo.set(record.key, updateRecord.content);\n                if (saveRecord.failure)\n                    return ServiceResult.Failed(saveRecord.error);\n            }\n            else {\n                const createRecord = ReconciledRecord.create(record, userId);\n                if (createRecord.failure)\n                    return ServiceResult.Failed(createRecord.error);\n                const saveReconRecord = this.keyValueRepo.set(record.key, createRecord.content);\n                if (saveReconRecord.failure)\n                    return ServiceResult.Failed(saveReconRecord.error);\n            }\n        }\n        return ServiceResult.Succeeded(\"data has ingested successfully\");\n    }\n}\nconst ingestService = new IngestService(keyValueRepository);\n\nexport { IngestService, ingestService as default };\n"},{"name":"services/reporting-service.js","module":"import { ServiceResult } from '../utils/service-result.js';\nimport keyValueRepository from '../repositories/kv-repository.js';\nimport { SummaryRecord } from '../models/summary-record.js';\n\nclass ReportingService {\n    constructor(repository) {\n        this.repository = repository;\n    }\n    getDataById(memberId, key) {\n        if (!key || key.length == 0)\n            return ServiceResult.Failed({\n                errorMessage: \"Error: key cannot be null or empty\",\n                errorType: \"InvalidKey\",\n            });\n        const record = this.repository.get(key);\n        if (record.failure)\n            return ServiceResult.Failed(record.error, record.statusCode);\n        return SummaryRecord.create(memberId, record.content);\n    }\n    getData(memberId) {\n        const result = [];\n        this.repository.forEach((key, value) => {\n            const summary = SummaryRecord.create(memberId, value);\n            if (summary.success)\n                result.push(summary.content);\n        });\n        return ServiceResult.Succeeded(result);\n    }\n}\nconst reportingService = new ReportingService(keyValueRepository);\n\nexport { ReportingService, reportingService as default };\n"},{"name":"utils/api-result.js","module":"import { ServiceResult } from './service-result.js';\n\nvar StatusCode;\n(function (StatusCode) {\n    StatusCode[StatusCode[\"OK\"] = 200] = \"OK\";\n    StatusCode[StatusCode[\"BAD_REQUEST\"] = 400] = \"BAD_REQUEST\";\n    StatusCode[StatusCode[\"UNAUTHORIZED\"] = 401] = \"UNAUTHORIZED\";\n})(StatusCode || (StatusCode = {}));\nclass ApiResult {\n    static Succeeded(result) {\n        const response = {\n            statusCode: result.statusCode,\n            body: result,\n        };\n        return response;\n    }\n    static Failed(result) {\n        const response = {\n            statusCode: result.statusCode,\n            body: result,\n        };\n        return response;\n    }\n    static AuthFailure() {\n        const response = {\n            statusCode: StatusCode.UNAUTHORIZED,\n            body: ServiceResult.Failed({\n                errorMessage: \"Unauthorized\",\n                errorType: \"Unauthorized\",\n            }, StatusCode.UNAUTHORIZED),\n        };\n        return response;\n    }\n}\n\nexport { ApiResult, StatusCode };\n"},{"name":"utils/constants.js","module":"const MINIMUM_VOTES_THRESHOLD = 3;\n\nexport { MINIMUM_VOTES_THRESHOLD };\n"},{"name":"utils/service-result.js","module":"class ServiceResult {\n    constructor(content, error, success, statusCode) {\n        this.content = content;\n        this.error = error;\n        this.success = success;\n        this.failure = !success;\n        this.statusCode = statusCode;\n        this.status = success ? \"Success\" : \"Error\";\n    }\n    static Succeeded(content) {\n        return new ServiceResult(content, null, true, 200);\n    }\n    static Failed(error, statusCode = 400) {\n        return new ServiceResult(null, error, false, statusCode);\n    }\n}\n\nexport { ServiceResult };\n"}]},"disable_bytecode_cache":false}}]}